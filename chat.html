<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Moderno</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Estilos base para PC (aplican por defecto y son sobrescritos en Android por la media query) */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevenir scroll del body */
            font-family: 'Roboto', sans-serif;
            background-color: #f0f2f5; /* Fondo gris claro para el body en PC */
        }

        #chat-container {
            width: 90%;
            max-width: 1000px; /* Ancho máximo para PC */
            height: 90vh;
            max-height: 90vh;
            background-color: #ffffff;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            margin: 5vh auto; /* Centrar en PC */
            box-sizing: border-box;
        }

        #name-prompt {
            padding: 50px 30px;
            text-align: center;
            background-color: #ffffff;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            box-sizing: border-box;
        }

        #name-prompt h2 {
            margin-top: 0;
            color: #333;
            font-size: 2em;
            margin-bottom: 25px;
        }

        #name-prompt input {
            padding: 15px 20px;
            margin-bottom: 20px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 1.2em;
            box-sizing: border-box;
            width: 60%;
            max-width: 400px;
            text-align: center;
        }

        #name-prompt button {
            padding: 15px 30px;
            background-color: #1a73e8;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.2em;
            transition: background-color 0.3s ease-in-out;
        }

        #name-prompt button:hover {
            background-color: #0f62da;
        }

        #chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px;
            background-color: #1a73e8;
            color: white;
            flex-shrink: 0;
            position: relative;
            border-bottom: none;
        }

        #chat-header h2 {
            margin: 0;
            font-size: 1.4em;
            color: white;
        }

        #online-users {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 3px;
            min-height: 1.2em;
        }

        #settings-button {
            width: 40px;
            height: 40px;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: transparent;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.5em;
            color: white; /* Color blanco en header azul */
            line-height: 1;
            vertical-align: middle;
            transition: background-color 0.2s ease-in-out;
        }

        #settings-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        #settings-dropdown {
            position: absolute;
            top: 55px;
            right: 15px;
            background-color: #ffffff;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-radius: 5px;
            display: none;
            flex-direction: column;
            z-index: 10;
            overflow: hidden;
        }

        #settings-dropdown button {
            padding: 10px 20px;
            border: none;
            background-color: transparent;
            text-align: left;
            cursor: pointer;
            font-size: 1em;
            color: #333;
            transition: background-color 0.2s ease-in-out;
        }

        #settings-dropdown button:hover {
            background-color: #f0f0f0;
        }

        #chat-box {
            flex-grow: 1;
            padding: 20px 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background-image: url('https://images.unsplash.com/photo-1518655048521-f130df041722?q=80&w=2070&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            padding-bottom: 20px; /* Ajustado por JS */
        }

        .message {
            padding: 14px 20px;
            border-radius: 20px;
            max-width: 70%; /* Más estrecho en PC */
            word-wrap: break-word;
            position: relative;
            line-height: 1.6;
            font-size: 1.1em;
            background-color: rgba(255, 255, 255, 0.95);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            z-index: 1;
            box-shadow: 0 1px 0.5px rgba(0, 0, 0, 0.1);
        }

        .message .name {
             font-size: 0.95em;
             color: #333;
             margin-bottom: 3px;
             display: block;
             font-weight: 600;
        }

        .message .text {
            display: block;
            font-size: 1em;
             flex-grow: 1;
             min-width: 0;
             margin-right: auto;
             padding-right: 10px;
             overflow-wrap: break-word;
             word-break: break-word;
        }

        .message a {
            color: #1a73e8;
            text-decoration: none;
        }

        .message a:hover {
            text-decoration: underline;
        }

         .message-footer {
             display: flex;
             align-items: center;
             justify-content: flex-end;
             flex-wrap: wrap;
             gap: 6px;
             margin-top: 5px;
         }

        .message .timestamp {
            font-size: 0.75em;
            color: #888;
            display: inline-block;
             flex-shrink: 0;
        }

         .message .checkmarks {
             font-size: 0.85em;
             color: #1a73e8;
             vertical-align: middle;
             display: inline;
             flex-shrink: 0;
         }

        .message.received {
            background-color: #e9e9eb;
            align-self: flex-start;
            border-bottom-left-radius: 6px;
        }

        .message.sent {
            background-color: #1a73e8;
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 6px;
        }

        .message.sent .name,
        .message.sent .text,
        .message.sent .timestamp {
             color: white !important;
        }
         .message.sent .timestamp {
             color: rgba(255, 255, 255, 0.8) !important;
         }
         .message.sent .checkmarks {
             color: white !important;
         }

         .reply-content {
             border-left: 4px solid #1a73e8;
             padding-left: 8px;
             margin-bottom: 8px;
             opacity: 0.8;
             font-size: 0.9em;
         }

         .reply-content .reply-name {
             font-weight: bold;
             color: inherit;
             display: block;
             margin-bottom: 2px;
         }

         .reply-content .reply-text {
             color: inherit;
             display: block;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
         }

        .video-preview-container {
            margin-top: 10px;
            margin-bottom: 6px;
            width: 100%;
            aspect-ratio: 16 / 9;
            overflow: hidden;
            border-radius: 8px;
             background-color: #000;
        }

        .video-preview-container iframe,
        .video-preview-container video {
            width: 100%;
            height: 100%;
            border: none;
        }

        #bottom-fixed-area {
            position: relative; /* Relativo al contenedor en PC */
            bottom: auto;
            left: auto;
            right: auto;
            width: 100%;
            max-width: none;
            box-sizing: border-box;
            margin: 0;
            z-index: 5;
            display: flex;
            flex-direction: column;
            background-color: #ffffff;
            border-top: 1px solid #eee;
            padding: 10px 30px;
        }

         #typing-indicator {
             font-size: 0.9em;
             color: #555;
             height: 1.2em;
             margin-bottom: 8px;
             text-align: left; /* Alineado a la izquierda en PC */
             padding: 0 5px;
         }

         #reply-preview {
             display: none;
             background-color: #f0f0f0;
             border-left: 4px solid #1a73e8;
             padding: 10px 15px;
             margin-bottom: 10px;
             border-radius: 5px;
             align-items: center;
             justify-content: space-between;
             font-size: 0.95em;
             color: #555;
         }

         #reply-preview .reply-name {
             font-weight: bold;
             margin-right: 5px;
         }

         #reply-preview .reply-text {
             flex-grow: 1;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
             margin-right: 10px;
         }

         #reply-preview #cancel-reply-button {
             background-color: transparent;
             border: none;
             font-size: 1.2em;
             cursor: pointer;
             color: #888;
             padding: 0;
             line-height: 1;
         }

         #reply-preview #cancel-reply-button:hover {
             color: #555;
         }

         .message-input-area {
             display: flex;
             gap: 10px;
             align-items: flex-end;
             flex-shrink: 0;
         }

         .message-input-area textarea {
             flex-grow: 1;
             padding: 12px 15px;
             border: 1px solid #ccc;
             border-radius: 20px;
             font-size: 1.1em;
             min-height: 45px;
             max-height: 150px;
             resize: none;
             overflow-y: auto;
             box-sizing: border-box;
         }

         .message-input-area .input-buttons {
             display: flex;
             gap: 8px;
             align-items: flex-end;
             flex-shrink: 0;
         }

         #emoji-button, #send-button {
             width: auto;
             height: 45px;
             padding: 0 15px;
             border-radius: 20px; /* Bordes redondeados para PC */
             cursor: pointer;
             display: flex;
             justify-content: center;
             align-items: center;
             transition: background-color 0.2s ease-in-out;
         }

         #emoji-button {
             background-color: #f0f0f0;
             border: none;
             font-size: 1.3em;
             color: #555;
         }

         #emoji-button:hover {
             background-color: #e0e0e0;
         }

         #emoji-button svg {
             width: 24px;
             height: 24px;
             fill: #555;
         }

         #send-button {
             background-color: #1a73e8;
             color: white;
             border: none;
             font-size: 1.1em;
             font-weight: 500;
         }

         #send-button:hover {
             background-color: #0f62da;
         }

         #emoji-picker {
             position: absolute;
             bottom: 70px; /* Ajustado por JS */
             left: 30px; /* Ajustado por JS */
             background-color: #ffffff;
             box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
             border-radius: 8px;
             padding: 10px;
             display: none;
             flex-wrap: wrap;
             gap: 5px;
             max-width: 300px;
             z-index: 10;
         }

         #emoji-picker span {
             cursor: pointer;
             font-size: 1.5em;
             padding: 5px;
             border-radius: 4px;
             transition: background-color 0.1s ease-in-out;
         }

         #emoji-picker span:hover {
             background-color: #f0f0f0;
         }


        /* Media query para pantallas pequeñas (Android) */
        @media (max-width: 768px) {
            body {
                padding: 0;
                background-color: #ffffff;
            }
            #chat-container {
                width: 100vw;
                max-width: 100vw;
                height: 100vh;
                max-height: 100vh;
                border-radius: 0;
                 padding: 0;
                 margin: 0;
                 justify-content: flex-start;
                 align-items: stretch;
            }

            #name-prompt {
                padding: 20px 15px;
                 flex-grow: 1;
                 justify-content: center;
                 align-items: center;
                 background-color: #e5e5ea;
                 border-bottom: 1px solid #d1d1d6;
            }

            #name-prompt h2 {
                 font-size: 1.5em;
                 margin-bottom: 15px;
            }

            #name-prompt input,
            #name-prompt button {
                font-size: 1em;
                padding: 10px 12px;
            }

             #name-prompt input[type="text"] {
                 margin-right: 5px;
                 align-self: center;
                 width: 80%;
                 max-width: none;
                 text-align: left;
             }

             #bottom-fixed-area {
                 position: fixed;
                 bottom: 0;
                 left: 0;
                 right: 0;
                 max-width: 100vw;
                 padding: 10px 15px;
                 background-color: #f9f9f9;
                 border-top: 1px solid #eee;
             }

             .message-input-area {
                 display: flex;
                 gap: 5px;
                 align-items: center;
                 flex-shrink: 0;
             }

             .message-input-area .input-buttons {
                 display: flex;
                 gap: 5px;
                 align-items: center;
                 flex-shrink: 0;
             }

             .message-input-area textarea {
                 font-size: 1em;
                 padding: 8px 12px;
                 min-height: 40px;
                 max-height: 100px;
                 flex-grow: 1;
                 box-sizing: border-box;
                 border-radius: 20px;
                 border: 1px solid #d1d1d6;
             }

             .input-container {
                 flex-direction: row;
                 align-items: flex-end;
                 gap: 5px;
             }

             #emoji-button, #send-button {
                 width: 40px;
                 height: 40px;
                 padding: 0;
                 flex-shrink: 0;
                 align-self: center;
                 border-radius: 50%; /* Botones redondos en Android */
                 background-color: #e5e5ea;
                 border: none;
                 display: flex;
                 justify-content: center;
                 align-items: center;
             }
              #send-button {
                  width: auto;
                  padding: 10px 15px;
                  border-radius: 20px;
                  background-color: #007aff;
                  color: white;
              }

              #emoji-button svg, #settings-button svg {
                 width: 20px;
                 height: 20px;
              }

             #emoji-button svg {
                 fill: #3a3a3c;
             }

             #settings-button {
                 width: 40px;
                 height: 40px;
                 padding: 0;
                 align-self: center;
                 font-size: 1.5em;
                 line-height: 1;
                 vertical-align: middle;
                 color: #1c1c1e;
                 background-color: transparent;
                 border: none;
             }

             #settings-dropdown button {
                 font-size: 0.9em;
                 padding: 8px 12px;
             }

             .message {
                 max-width: 90%;
             }

             #typing-indicator {
                 padding: 0 5px;
                 text-align: right;
                 margin-bottom: 5px;
             }

             #emoji-picker {
                 left: 10px;
                 width: calc(100% - 20px);
                 background-color: #fff;
                 border: 1px solid #d1d1d6;
                 border-radius: 8px;
                 padding: 10px;
                 box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
                 flex-wrap: wrap;
                 gap: 5px;
                 max-height: 200px;
                 overflow-y: auto;
             }

             #emoji-picker span {
                 font-size: 1.5em;
                 padding: 3px;
             }

             #reply-preview {
                 padding: 8px 10px;
                 background-color: #e5e5ea;
                 border-left-color: #007aff;
             }

             #settings-dropdown {
                 top: 40px;
                 right: 10px;
                 left: auto;
                 background-color: #fff;
                 border: 1px solid #d1d1d6;
                 border-radius: 8px;
                 box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
                 min-width: 150px;
                 padding: 5px 0;
             }
        }

         /* Estilos para el botón de configuración en general (Móvil por defecto) */
         #settings-button {
             /* Ajuste de tamaño y posición */
             width: 40px;
             height: 40px;
             padding: 0;
             display: flex;
             justify-content: center;
             align-items: center;
             background-color: transparent; /* Fondo transparente */
             border: none;
             border-radius: 50%; /* Botón redondo */
             cursor: pointer;
             font-size: 1.5em; /* Tamaño para el emoji */
             color: #1c1c1e; /* Color oscuro para el emoji */
             /* Añadido para intentar centrar el emoji */
             line-height: 1;
             vertical-align: middle;
         }

         #settings-button:hover {
             background-color: #e5e5ea; /* Fondo gris claro al pasar el ratón */
         }


    </style>

    <script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-analytics-compat.js"></script>

</head>
<body>

    <div id="chat-container">
        <div id="name-prompt">
            <h2>Ingresa tu nombre</h2>
            <input type="text" id="name-input" placeholder="Tu nombre">
            <button id="start-chat-button">Entrar al Chat</button>
        </div>

        <div id="chat-interface">
            <div id="chat-header">
                 <div>
                     <h2>FACBA</h2>
                     <div id="online-users"></div> </div>
                 <button id="settings-button" title="Configuración">
                      ⚙️
                 </button>
                 <div id="settings-dropdown">
                     <button id="clear-chat-button">Limpiar Chat</button>
                     <button id="change-name-button">Cambiar Nombre</button>
                 </div>
            </div>
             <div id="chat-box">
                </div>
            <div id="bottom-fixed-area">
                <div id="typing-indicator"></div>
                 <div id="emoji-picker">
                     </div>
                 <div id="reply-preview">
                     <span class="reply-name"></span>
                     <span class="reply-text"></span>
                     <button id="cancel-reply-button">×</button>
                 </div>
                <div class="message-input-area">
                    <textarea id="message-input" placeholder="Escribe un mensaje..." autocomplete="off" autocorrect="off" rows="1"></textarea>
                    <div class="input-buttons">
                         <button id="emoji-button" title="Insertar Emoji">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm0 22c-5.514 0-10-4.486-10-10s4.486-10 10-10 10 4.486 10 10-4.486 10-10 10zm-3-8c.828 0 1.5-.672 1.5-1.5s-.672-1.5-1.5-1.5-1.5.672-1.5 1.5.672 1.5 1.5 1.5zm6 0c.828 0 1.5-.672 1.5-1.5s-.672-1.5-1.5-1.5-1.5.672-1.5 1.5.672 1.5 1.5 1.5zm-3 4c-2.04 0-3.831-1.242-4.588-3h9.176c-.757 1.758-2.548 3-4.588 3z"/>
                            </svg>
                        </button>
                         <button id="send-button">Enviar</button>
                    </div>
                 </div>
            </div>
             </div>
    </div>

    <audio id="notification-sound" src="sonido_mensaje.mp3" preload="auto"></audio>


    <script>
        // Configuración de tu aplicación web de Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyCimRCv6S5u0FhsfWrW_3A0dQJy0uAKVro",
            authDomain: "facba-69d41.firebaseapp.com",
            databaseURL: "https://facba-69d41-default-rtdb.firebaseio.com",
            projectId: "facba-69d41",
            storageBucket: "facba-69d41.firebasestorage.app",
            messagingSenderId: "264089433073",
            appId: "1:264089433073:web:968551648758972eb74a50",
            measurementId: "G-NL7Y6NDH99"
        };

        // Inicializar Firebase
        const app = firebase.initializeApp(firebaseConfig);
        const database = firebase.database(); // Obtener la instancia de Realtime Database

        let userName = ''; // Variable para almacenar el nombre del usuario
        let typingTimeout; // Para manejar el indicador de escribiendo
        let initialLoadComplete = false; // Bandera para saber si la carga inicial de mensajes ha terminado
        let audioUnlocked = false; // Bandera para rastrear si el audio se ha desbloqueado


        // Variable para almacenar los datos del mensaje al que se está respondiendo
        let replyingToMessage = null;

        // Intersection Observer para detectar cuando los mensajes son visibles
        let messageObserver;


        // Obtener elementos del DOM
        const namePrompt = document.getElementById('name-prompt');
        const nameInput = document.getElementById('name-input');
        const startChatButton = document.getElementById('start-chat-button');
        const chatInterface = document.getElementById('chat-interface');
        const chatBox = document.getElementById('chat-box');
        // Cambiado de input type="text" a textarea
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const typingIndicator = document.getElementById('typing-indicator'); // Elemento para el indicador
        const notificationSound = document.getElementById('notification-sound'); // Elemento de audio
        const emojiButton = document.getElementById('emoji-button'); // Botón de emoji
        const emojiPicker = document.getElementById('emoji-picker'); // Selector de emojis
        const replyPreview = document.getElementById('reply-preview'); // Vista previa de respuesta
        const replyNameSpan = replyPreview.querySelector('.reply-name');
        const replyTextSpan = replyPreview.querySelector('.reply-text');
        const cancelReplyButton = document.getElementById('cancel-reply-button');
        // Nuevos elementos para configuración
        const settingsButton = document.getElementById('settings-button'); // Ahora en chat-header
        const settingsDropdown = document.getElementById('settings-dropdown'); // Ahora en chat-header
        const clearChatButton = document.getElementById('clear-chat-button'); // Ahora dentro del dropdown
        const changeNameButton = document.getElementById('change-name-button'); // Nuevo botón para cambiar nombre
        const chatContainer = document.getElementById('chat-container'); // Referencia al contenedor principal
        const messageInputArea = document.querySelector('.message-input-area'); // Referencia al área de input
        const onlineUsersDiv = document.getElementById('online-users'); // Elemento para usuarios en línea
        const bottomFixedArea = document.getElementById('bottom-fixed-area'); // Nuevo contenedor fijo


        // --- Lógica de Ingreso de Nombre ---
        startChatButton.addEventListener('click', () => {
            const enteredName = nameInput.value.trim(); // Obtener el nombre y eliminar espacios en blanco
            if (enteredName) {
                userName = enteredName;
                namePrompt.style.display = 'none'; // Ocultar la sección de nombre
                chatInterface.style.display = 'flex'; // Mostrar la interfaz de chat
                messageInput.focus(); // Poner el foco en el campo de mensaje
                // Opcional: Guardar el nombre en localStorage para recordarlo
                localStorage.setItem('chatName', userName);
                initializeChat(); // Inicializar la carga de mensajes y listeners
            } else {
                // Usar un mensaje en el DOM en lugar de alert()
                // Podrías añadir un elemento div para mostrar errores
                 console.log('Por favor, ingresa un nombre.'); // Usar console.log como alternativa simple
            }
        });

        // Permitir presionar Enter en el campo de nombre
        nameInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                startChatButton.click(); // Simular clic en el botón
            }
        });

        // --- Función para inicializar la carga y los listeners del chat ---
        function initializeChat() {
             console.log("initializeChat function called.");
             setupMessageObserver(); // Configurar el Intersection Observer
             loadInitialMessages(); // Cargar mensajes existentes una vez
             setupRealtimeListeners(); // Configurar listeners en tiempo real una vez
             setupTypingIndicator(); // Configurar el indicador de escribiendo
             setupPresence(); // Configurar la presencia del usuario
             // El desbloqueo de audio ahora se maneja en la primera interacción del usuario (enviar mensaje)
        }


        // --- Lógica del Chat (Realtime Database) ---

        // Referencia al nodo 'messages' en la base de datos
        const messagesRef = database.ref('messages'); // 'messages' es el nombre del nodo
        // Referencia al nodo para el estado de escritura
        const typingRef = database.ref('typing');
        // Referencia al nodo para la presencia de usuarios
        const presenceRef = database.ref('presence');


        // Clave para limpiar el chat (¡Mantén esto seguro en una aplicación real!)
        const CLEAR_CHAT_PASSWORD = '170518';


        // Función para formatear el timestamp a HH:MM
        function formatTimestamp(timestamp) {
            if (!timestamp) return ''; // Manejar caso sin timestamp
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        // Función para enviar un mensaje (texto o respuesta)
        function sendMessage() {
            console.log("sendMessage function called."); // Debugging log
            const messageText = messageInput.value.trim(); // Obtener el texto del mensaje y limpiar
            console.log("Message text:", messageText); // Debugging log
            console.log("User name:", userName); // Debugging log

            if (messageText && userName) { // Asegurarse de que haya texto y nombre de usuario
                const newMessage = {
                    name: userName,
                    text: messageText,
                    timestamp: firebase.database.ServerValue.TIMESTAMP, // Usar el timestamp del servidor de Firebase
                    status: 'sent' // Estado inicial: enviado
                };

                // Si estamos respondiendo a un mensaje, añadir la referencia
                if (replyingToMessage) {
                    newMessage.replyTo = {
                        id: replyingToMessage.id, // ID único del mensaje original
                        name: replyingToMessage.name,
                        content: replyingToMessage.text ? replyingToMessage.text.substring(0, 50) + (replyingToMessage.text.length > 50 ? '...' : '') : 'Archivo' // Fragmento del texto o indicar que es archivo
                    };
                    console.log("Sending as a reply to:", replyingToMessage.id); // Debugging log
                }

                console.log("Attempting to send message to Realtime Database:", newMessage); // Debugging log

                // Enviar el nuevo mensaje a la base de datos
                messagesRef.push(newMessage)
                    .then(() => {
                        console.log("Mensaje enviado exitosamente a Realtime Database!");
                        messageInput.value = ''; // Limpiar el campo de entrada
                        setTypingStatus(false); // Limpiar estado de escritura
                        cancelReply(); // Cancelar el estado de respuesta después de enviar
                        // Después de enviar, ajustar la altura del textarea a la mínima
                        messageInput.style.height = 'auto';
                    })
                    .catch((error) => {
                        console.error("Error al enviar mensaje a Realtime Database:", error);
                        // Mostrar mensaje de error al usuario
                    });
            } else {
                 console.log("Message not sent: text or user name missing."); // Debugging log
            }
        }

        // Listener para el botón de enviar texto
        sendButton.addEventListener('click', sendMessage);

        // Permitir presionar Enter en el campo de mensaje de texto (solo si no hay Shift)
        messageInput.addEventListener('keypress', (event) => {
            // Si es Enter y no Shift+Enter
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault(); // Prevenir el salto de línea por defecto
                sendMessage(); // Enviar el mensaje
            }
            // Si es Shift+Enter, permitir el salto de línea
        });


         // --- Lógica de Ajuste de Altura del Textarea ---

        // Función para ajustar la altura del textarea automáticamente
        function adjustTextareaHeight() {
             // Restablecer la altura a 'auto' para que se recalcule correctamente
            messageInput.style.height = 'auto';
            // Establecer la altura al scrollHeight (altura necesaria para mostrar todo el contenido)
            // Limitar por max-height definido en CSS
            messageInput.style.height = messageInput.scrollHeight + 'px';
            // Después de ajustar la altura del textarea, ajustar el padding inferior del chatBox
            adjustChatBoxPadding();
        }

        // Listener para el evento 'input' en el textarea para ajustar la altura
        messageInput.addEventListener('input', adjustTextareaHeight);


         // --- Lógica del Indicador de Escribiendo (Realtime Database) ---

        // Función para establecer el estado de escritura en Realtime Database
        function setTypingStatus(isTyping) {
            if (!userName) return; // No hacer nada si el nombre del usuario no está establecido

            const userTypingRef = typingRef.child(userName); // Referencia al estado del usuario actual en RTDB

            if (isTyping) {
                userTypingRef.set(true); // Establecer el estado a true
                // Limpiar el estado después de un tiempo si el usuario deja de escribir
                if (typingTimeout) clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    userTypingRef.remove(); // Eliminar el estado después de 1.5 segundos
                }, 1500);
            } else {
                 // Limpiar el timeout si existe
                 if (typingTimeout) {
                     clearTimeout(typingTimeout);
                     typingTimeout = null;
                 }
                 userTypingRef.remove(); // Eliminar el estado si ya no está escribiendo
            }
        }

        // Listener para el campo de entrada de mensaje para detectar escritura
        messageInput.addEventListener('input', () => {
            if (messageInput.value.trim().length > 0) {
                setTypingStatus(true); // El usuario está escribiendo
            } else {
                setTypingStatus(false); // El usuario ha borrado el texto
            }
        });

        // Configurar el listener para el estado de escritura de otros usuarios
        function setupTypingIndicator() {
            typingRef.on('value', (snapshot) => { // Listener en RTDB
                const typingUsers = snapshot.val();
                const usersTyping = [];

                if (typingUsers) {
                    // Iterar sobre los usuarios que están escribiendo
                    for (const name in typingUsers) {
                        // Asegurarse de que no sea el usuario actual
                        if (name !== userName) {
                            usersTyping.push(name);
                        }
                    }
                }

                // Actualizar el texto del indicador
                if (usersTyping.length > 0) {
                    typingIndicator.textContent = `${usersTyping.join(', ')} está escribiendo...`;
                } else {
                    typingIndicator.textContent = ''; // Limpiar si nadie está escribiendo
                }
                // Después de actualizar el indicador, ajustar el padding del chatBox
                adjustChatBoxPadding();
            });
        }


        // --- Lógica para Cargar Mensajes Iniciales (Realtime Database) ---
        function loadInitialMessages() {
             console.log("loadInitialMessages function called."); // Debugging log

             // Cargar mensajes existentes una vez al inicio
             messagesRef.once('value', (snapshot) => {
                 console.log("Initial message load from Realtime Database complete.");
                 const messages = snapshot.val();
                 if (messages) {
                     // Convertir objeto de mensajes a array y ordenar por timestamp
                     const messageList = Object.keys(messages).map(key => ({ id: key, ...messages[key] }));
                     messageList.sort((a, b) => a.timestamp - b.timestamp);

                     // Limpiar el chatbox antes de cargar los mensajes existentes
                     chatBox.innerHTML = '';

                     messageList.forEach((msg) => {
                         displayMessage(msg, msg.id); // Pasar el ID a displayMessage
                     });
                 }
                 chatBox.scrollTop = chatBox.scrollHeight; // Scroll al final
                 initialLoadComplete = true; // Marcar la carga inicial como completa
             }, (error) => {
                 console.error("Error fetching initial messages from Realtime Database:", error);
             });
        }

        // --- Lógica para Configurar Listeners en Tiempo Real (Realtime Database) ---
        function setupRealtimeListeners() {
            console.log("setupRealtimeListeners function called.");

             // Escuchar en tiempo real los mensajes nuevos desde Realtime Database
             // Este listener solo se adjunta UNA VEZ
             messagesRef.on('child_added', (data) => {
                 const newMessage = data.val();
                 const messageId = data.key; // Obtener el ID único del mensaje
                 console.log(`[${userName}] child_added event:`, newMessage, "ID:", messageId); // Debugging log con nombre de usuario

                 // Solo mostrar el mensaje si no es parte de la carga inicial
                 // La bandera initialLoadComplete ayuda a diferenciar
                 if (initialLoadComplete) {
                    displayMessage(newMessage, messageId); // Mostrar el nuevo mensaje
                    // Reproducir sonido si el mensaje no es del usuario actual
                     if (newMessage.name !== userName) {
                         playNotificationSound();
                     }
                    chatBox.scrollTop = chatBox.scrollHeight; // Scroll al final
                 } else {
                     // Si aún no ha terminado la carga inicial, no hacemos nada con este evento
                     // porque ya se mostrará en loadInitialMessages
                     console.log(`[${userName}] Ignoring child_added event during initial load.`); // Debugging log con nombre de usuario
                 }

             }, (error) => {
                 console.error(`[${userName}] Error in realtime listener for messages (child_added):`, error); // Debugging log con nombre de usuario
             });

             // Listener para actualizar el estado de los mensajes (para doble check)
             messagesRef.on('child_changed', (data) => {
                 const changedMessage = data.val();
                 const messageId = data.key;
                 console.log(`[${userName}] child_changed event: Message ${messageId} changed to:`, changedMessage); // Debugging log con nombre de usuario

                 // Si el mensaje cambiado es del usuario actual y su estado es 'read', actualizar la UI
                 if (changedMessage.name === userName && changedMessage.status === 'read') {
                     const messageElement = chatBox.querySelector(`[data-message-id="${messageId}"]`);
                     if (messageElement) {
                         // Encontrar el message-footer dentro del mensaje
                         const messageFooter = messageElement.querySelector('.message-footer');
                         if (messageFooter) {
                             // Eliminar checkmarks existentes si los hay
                             const existingCheckmarks = messageFooter.querySelector('.checkmarks');
                             if (existingCheckmarks) {
                                 existingCheckmarks.remove();
                             }

                             const checkmarksSpan = document.createElement('span');
                             checkmarksSpan.classList.add('checkmarks');
                             checkmarksSpan.textContent = '✓✓'; // Doble checkmark Unicode
                             // Añadir los checkmarks al final del message-footer
                             messageFooter.appendChild(checkmarksSpan);
                             console.log(`[${userName}] Updated message ${messageId} to double check.`); // Debugging log con nombre de usuario
                         }
                     }
                 }
             }, (error) => {
                 console.error(`[${userName}] Error in realtime listener for message changes (child_changed):`, error); // Debugging log con nombre de usuario
             });
        }


        // --- Configurar Intersection Observer ---
        function setupMessageObserver() {
            const options = {
                root: chatBox, // Observar dentro del chatBox
                rootMargin: '0px',
                threshold: 0.5 // El mensaje se considera visible si al menos el 50% está en el viewport
            };

            messageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    // Si el mensaje es visible (intersecting) y es un mensaje recibido por este usuario
                    if (entry.isIntersecting && entry.target.classList.contains('received')) {
                        const messageElement = entry.target;
                        const messageId = messageElement.dataset.messageId;
                        // Obtener el estado actual del mensaje de la base de datos para evitar escrituras innecesarias
                        messagesRef.child(messageId).once('value', (snapshot) => {
                            const messageData = snapshot.val();
                            // Mark as read only if the status is not already 'read'
                            if (messageData && messageData.status !== 'read') {
                                console.log(`[${userName}] Message ${messageId} is now visible. Marking as read.`);
                                messagesRef.child(messageId).update({ status: 'read' })
                                    .then(() => console.log(`[${userName}] Message ${messageId} marked as read successfully via Observer.`))
                                    .catch(error => console.error(`[${userName}] Error marking message ${messageId} as read via Observer:`, error));
                            } else {
                                console.log(`[${userName}] Message ${messageId} is visible but already read or not found.`);
                            }
                        });
                        // Dejar de observar este mensaje una vez que se marca como leído
                        observer.unobserve(messageElement);
                    }
                });
            }, options);
             console.log(`[${userName}] Intersection Observer configured.`);
        }


        // Función para mostrar un mensaje en el DOM
        function displayMessage(msg, messageId) {
            console.log(`[${userName}] Displaying message:`, msg, "ID:", messageId); // Debugging log con nombre de usuario

            const messageElement = document.createElement('div');
            messageElement.classList.add('message');
            messageElement.dataset.messageId = messageId; // Almacenar el ID del mensaje en el elemento DOM

            // Añadir clase 'sent' o 'received'
            if (msg.name === userName) {
                messageElement.classList.add('sent');
                 console.log(`[${userName}] Message ${messageId} is SENT. Initial status: ${msg.status}`); // Log initial status for sent message
            } else {
                messageElement.classList.add('received');
                 console.log(`[${userName}] Message ${messageId} is RECEIVED from ${msg.name}.`); // Debugging log con nombre de usuario
                // La lógica para marcar como leído ahora está en el Intersection Observer
            }

            // Crear elementos para el nombre y contenido
            const nameSpan = document.createElement('span');
            nameSpan.classList.add('name');
            /* Solo mostrar el nombre si no es el mensaje del usuario actual (opcional, estilo WhatsApp) */
            if (msg.name !== userName) {
               nameSpan.textContent = msg.name + ': ';
            } else {
               nameSpan.textContent = ''; // No mostrar el nombre en mensajes propios
            }

            // Crear el contenedor para el texto, hora y checkmarks
            const messageFooter = document.createElement('div');
            messageFooter.classList.add('message-footer');

            // Crear elementos para el texto y timestamp
            const textSpan = document.createElement('span');
            textSpan.classList.add('text');
            textSpan.textContent = msg.text;
            console.log(`[${userName}] textSpan created for message ${messageId}. Content: "${textSpan.textContent}"`); // Debugging log: contenido del texto

            // --- Aplicar estilos inline para asegurar visibilidad y color ---
            // Estos estilos inline tienen alta prioridad y deberían forzar la visibilidad y color.
            textSpan.style.visibility = 'visible';
            textSpan.style.display = 'block'; // O 'inline-block' si prefieres
            if (msg.name === userName) {
                textSpan.style.color = 'white'; // Color blanco para mensajes enviados
            } else {
                textSpan.style.color = '#1c1c1e'; // Color oscuro para mensajes recibidos
            }
            console.log(`[${userName}] textSpan for message ${messageId} inline styles applied -> Color: ${textSpan.style.color}, Visibility: ${textSpan.style.visibility}, Display: ${textSpan.style.display}`); // Log inline styles


            const timestampSpan = document.createElement('span');
            timestampSpan.classList.add('timestamp');
            timestampSpan.textContent = formatTimestamp(msg.timestamp); // Formatear y mostrar hora


            // Añadir nombre al elemento del mensaje si no es el usuario actual
            if (msg.name !== userName) {
                 messageElement.appendChild(nameSpan);
            }

            // --- Mostrar contenido de la respuesta si existe ---
            if (msg.replyTo) {
                const replyContentDiv = document.createElement('div');
                replyContentDiv.classList.add('reply-content');

                const replyName = document.createElement('span');
                replyName.classList.add('reply-name');
                replyName.textContent = msg.replyTo.name + ':';

                const replyText = document.createElement('span');
                replyText.classList.add('reply-text');
                replyText.textContent = msg.replyTo.content;

                replyContentDiv.appendChild(replyName);
                replyContentDiv.appendChild(replyText);
                messageElement.appendChild(replyContentDiv);
            }
            /* --- Fin de mostrar contenido de respuesta --- */

            // --- Lógica para detectar y mostrar previsualización de videos o enlaces ---
            let contentElement = null; // Elemento que contendrá la previsualización o el texto del enlace

            // 1. Intentar detectar YouTube
            const youtubeUrlMatch = msg.text ? msg.text.match(/(?:https?:\/\/)?(?:www\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=)?([a-zA-Z0-9_-]+)/) : null;
            if (youtubeUrlMatch && youtubeUrlMatch[1]) {
                const videoId = youtubeUrlMatch[1];
                const iframe = document.createElement('iframe');
                iframe.src = `https://www.youtube.com/embed/${videoId}`; // URL de incrustación estándar de YouTube
                iframe.setAttribute('allowfullscreen', ''); // Permitir pantalla completa
                iframe.setAttribute('loading', 'lazy'); // Carga diferida
                contentElement = iframe;
                console.log(`[${userName}] YouTube video detected for message ${messageId}. Video ID: ${videoId}`);
            } else {
                // 2. Intentar detectar Facebook Video (regex mejorada, pero puede no ser exhaustiva)
                const facebookUrlMatch = msg.text ? msg.text.match(/(?:https?:\/\/)?(?:www\.)?(?:facebook\.com)\/(?:watch\/)?(?:v=)?(?:videos\/)?([0-9]+)(?:\/)?/) : null;
                 if (facebookUrlMatch && facebookUrlMatch[1]) {
                     const videoId = facebookUrlMatch[1];
                     const iframe = document.createElement('iframe');
                     // URL de incrustación básica de Facebook (puede requerir ajustes dependiendo de la configuración)
                     iframe.src = `https://www.facebook.com/plugins/video.php?href=https%3A%2F%2Fwww.facebook.com%2Fwatch%2F%3Fv%3D${videoId}&show_text=0&width=560`;
                     iframe.setAttribute('allowfullscreen', '');
                     iframe.setAttribute('loading', 'lazy');
                     iframe.setAttribute('scrolling', 'no');
                     iframe.setAttribute('frameborder', '0');
                     iframe.setAttribute('allow', 'autoplay; clipboard-write; encrypted-media; picture-in-picture; web-share');
                     contentElement = iframe;
                     console.log(`[${userName}] Facebook video detected for message ${messageId}. Video ID: ${videoId}`);
                 } else {
                     // 3. Intentar detectar enlaces directos a archivos de video
                     const videoFileMatch = msg.text ? msg.text.match(/(https?:\/\/[^\s]+\.(mp4|webm|ogg))/) : null;
                     if (videoFileMatch && videoFileMatch[1]) {
                         const videoUrl = videoFileMatch[1];
                         const videoElement = document.createElement('video');
                         videoElement.src = videoUrl;
                         videoElement.setAttribute('controls', ''); // Mostrar controles de video
                         videoElement.setAttribute('preload', 'metadata'); // Cargar metadatos primero
                         contentElement = videoElement;
                         console.log(`[${userName}] Direct video file detected for message ${messageId}. URL: ${videoUrl}`);
                     } else {
                         // 4. Si no es un video soportado, mostrar el texto del mensaje con enlaces clicables
                         // Detectar URLs generales en el texto y convertirlas en enlaces clicables
                         const urlRegex = /(https?:\/\/[^\s]+)/g;
                         const textWithLinks = msg.text.replace(urlRegex, '<a href="$1" target="_blank">$1</a>');
                         textSpan.innerHTML = textWithLinks; // Usar innerHTML para renderizar el enlace
                         contentElement = textSpan; // El texto con enlaces es el contenido principal
                         console.log(`[${userName}] No supported video detected for message ${messageId}. Displaying text with links.`);
                     }
                 }
            }

            // Si se encontró una previsualización de video, crear un contenedor y añadirla
            if (contentElement && (contentElement.tagName === 'IFRAME' || contentElement.tagName === 'VIDEO')) {
                const videoPreviewContainer = document.createElement('div');
                videoPreviewContainer.classList.add('video-preview-container');
                videoPreviewContainer.appendChild(contentElement);
                messageElement.appendChild(videoPreviewContainer); // Añadir el contenedor de previsualización al messageElement

                // Después de añadir la previsualización, añadir el texto original si no es solo la URL
                 if (msg.text && !youtubeUrlMatch && !facebookUrlMatch && !videoFileMatch) {
                     // Si el mensaje contenía texto además de la URL, añadir el textSpan original (ahora con enlaces clicables)
                     messageElement.appendChild(textSpan);
                     console.log(`[${userName}] Adding original textSpan after video preview for message ${messageId}.`);
                 } else if (msg.text && (youtubeUrlMatch || facebookUrlMatch || videoFileMatch)) {
                     // Si el mensaje es solo la URL del video, no es necesario añadir el textSpan de nuevo
                     console.log(`[${userName}] Message is only a video URL, not adding textSpan again for message ${messageId}.`);
                 }


            } else if (contentElement && contentElement.classList.contains('text')) {
                 // Si el contenido principal es el textSpan (con enlaces clicables)
                 messageElement.appendChild(contentElement); // Añadir el textSpan (que ya tiene el contenido)
                 console.log(`[${userName}] Adding textSpan as main content for message ${messageId}.`);
            }


            // --- Añadir hora y checkmarks al footer ---
            messageFooter.appendChild(timestampSpan); // Añadir la hora

            // Añadir checkmarks si es un mensaje enviado por el usuario actual
            if (msg.name === userName) {
                 const checkmarksSpan = document.createElement('span');
                 checkmarksSpan.classList.add('checkmarks');
                 // Mostrar un check simple si el estado es 'sent', doble si es 'read'
                 checkmarksSpan.textContent = msg.status === 'read' ? '✓✓' : '✓'; // Unicode checkmarks
                 messageFooter.appendChild(checkmarksSpan); // Añadir los checkmarks al footer
                 console.log(`[${userName}] Displaying checkmarks for SENT message ${messageId}: ${checkmarksSpan.textContent}, based on status "${msg.status}"`); // Debugging log con nombre de usuario
            } else {
                 console.log(`[${userName}] Not displaying checkmarks for RECEIVED message ${messageId}.`); // Debugging log con nombre de usuario
            }

            messageElement.appendChild(messageFooter); // Asegurarse de que el footer se añade al messageElement
            console.log(`[${userName}] messageFooter appended to messageElement for message ${messageId}.`); // Log after appending messageFooter

            chatBox.appendChild(messageElement);
            console.log(`[${userName}] messageElement appended to chatBox for message ${messageId}.`); // Log after appending messageElement
            console.log(`[${userName}] chatBox after appending message ${messageId}:`, chatBox.innerHTML); // Log chatBox content


            // Después de añadir el messageElement al DOM, podemos obtener los estilos computados del textSpan
            // Aumentar el retraso para dar más tiempo a la renderización
            setTimeout(() => {
                 // Verificar si textSpan existe antes de intentar obtener estilos computados
                 if (textSpan && textSpan.parentElement) { // Asegurarse de que textSpan está en el DOM
                     const computedStyle = window.getComputedStyle(textSpan);
                     console.log(`[${userName}] textSpan for message ${messageId} computed style -> Color: ${computedStyle.color}, Visibility: ${computedStyle.visibility}, Display: ${computedStyle.display}`);
                 } else {
                     console.log(`[${userName}] textSpan not found in DOM for message ${messageId}. Skipping computed style log.`);
                 }


                 // Verificar también el estilo computado del messageFooter
                 const computedFooterStyle = window.getComputedStyle(messageFooter);
                 console.log(`[${userName}] messageFooter for message ${messageId} computed style -> Display: ${computedFooterStyle.display}, Visibility: ${computedFooterStyle.visibility}, Opacity: ${computedFooterStyle.opacity}`);

                 // Observar el mensaje si es un mensaje recibido
                 if (messageElement.classList.contains('received')) {
                     messageObserver.observe(messageElement);
                     console.log(`[${userName}] Observing received message ${messageId} with Intersection Observer.`);
                 }


            }, 500); // Retraso aumentado a 500ms


             // Reproducir sonido solo para mensajes entrantes que no sean del usuario actual
             if (initialLoadComplete && msg.name !== userName) {
                 playNotificationSound();
             }

             // Añadir listener de clic para responder
             messageElement.addEventListener('click', () => {
                 // Crear un objeto con los datos necesarios para la respuesta
                 const messageDataForReply = {
                     id: messageId,
                     name: msg.name,
                     text: msg.text || '', // Usar texto si existe, vacío si es archivo
                     // Puedes añadir más propiedades si quieres referenciar archivos en el futuro
                 };
                 startReply(messageDataForReply);
             });
        }

        // Función para reproducir el sonido de notificación
        function playNotificationSound() {
             if (notificationSound && audioUnlocked) { // Solo reproducir si el audio está desbloqueado
                 notificationSound.currentTime = 0; // Reiniciar el sonido si ya se está reproduciendo
                 notificationSound.play().catch(error => {
                     console.error("Error al reproducir el sonido:", error);
                     // Esto a menudo ocurre si el navegador bloquea el autoplay
                 });
             } else if (!audioUnlocked) {
                 console.log("Audio not unlocked yet. Cannot play sound.");
             }
        }

        // Función para intentar desbloquear el audio con una interacción del usuario
        function unlockAudio() {
            if (notificationSound && notificationSound.readyState >= 2 && !audioUnlocked) { // readyState 2 means enough data is available
                notificationSound.volume = 0; // Set volume to 0
                const playPromise = notificationSound.play();

                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        // Playback started successfully
                        notificationSound.pause(); // Pause immediately
                        notificationSound.volume = 1; // Restore volume
                        audioUnlocked = true; // Mark audio as unlocked
                        console.log("Audio unlocked successfully.");
                        // Remove this listener after first interaction
                        document.removeEventListener('click', unlockAudio);
                        document.removeEventListener('touchstart', unlockAudio);
                        sendButton.removeEventListener('click', unlockAudio); // Remove from send button too
                    }).catch(error => {
                        // Playback failed, likely due to user interaction requirement
                        console.error("Audio unlock failed:", error);
                        audioUnlocked = false; // Keep audio locked
                    });
                }
            } else if (audioUnlocked) {
                 console.log("Audio already unlocked.");
                 // Remove listeners if already unlocked
                 document.removeEventListener('click', unlockAudio);
                 document.removeEventListener('touchstart', unlockAudio);
                 sendButton.removeEventListener('click', unlockAudio); // Remove from send button too
            } else {
                 console.log("Notification sound not ready or not found.");
            }
        }


        // --- Lógica para Limpiar Chat con Clave (Realtime Database) ---
        // El listener ahora está asociado al botón dentro del dropdown
        clearChatButton.addEventListener('click', () => {
            // Ocultar el dropdown antes de mostrar el prompt
            settingsDropdown.style.display = 'none';

            // Usar prompt() para solicitar la clave
            const enteredPassword = prompt("Ingresa la clave para limpiar el chat:");

            // Verificar la clave
            if (enteredPassword === CLEAR_CHAT_PASSWORD) {
                // Si la clave es correcta, eliminar el nodo 'messages' de Realtime Database
                messagesRef.remove()
                    .then(() => {
                        console.log("Chat limpiado exitosamente en Realtime Database!");
                        // La UI se actualizará automáticamente gracias al listener on 'child_added'
                    })
                    .catch((error) => {
                        console.error("Error al limpiar el chat en Realtime Database:", error);
                        // Mostrar mensaje de error al usuario
                    });
            } else {
                // Si la clave es incorrecta
                console.log("Clave incorrecta. El chat no fue limpiado.");
                // Mostrar mensaje de clave incorrecta al usuario
            }
        });

        // --- Lógica para Cambiar Nombre ---
        changeNameButton.addEventListener('click', () => {
            // Ocultar el dropdown antes de mostrar el prompt
            settingsDropdown.style.display = 'none';

            const newName = prompt("Ingresa tu nuevo nombre:");
            if (newName && newName.trim() !== '' && newName.trim() !== userName) {
                userName = newName.trim();
                localStorage.setItem('chatName', userName);
                console.log(`Nombre cambiado a: ${userName}`);
                // Recargar la página para actualizar la interfaz y la presencia
                location.reload();
            } else if (newName && newName.trim() === userName) {
                console.log("El nuevo nombre es el mismo que el actual.");
            } else {
                console.log("Cambio de nombre cancelado o nombre inválido.");
            }
        });


        // --- Lógica del Botón de Emoji y Selector ---

        // Lista de emojis para el selector
        const emojis = ['😊', '😂', '❤️', '👍', '🙏', '😢', '😍', '🥳', '😎', '🤩', '😭', '🥰', '😘'];

        // Llenar el selector de emojis
        emojis.forEach(emoji => {
            const emojiSpan = document.createElement('span');
            emojiSpan.textContent = emoji;
            emojiPicker.appendChild(emojiSpan);

            // Añadir listener para insertar el emoji en el input
            emojiSpan.addEventListener('click', () => {
                insertEmoji(emoji);
                // Opcional: Ocultar el selector después de seleccionar un emoji
                // emojiPicker.style.display = 'none';
            });
        });

        // Función para insertar emoji en el textarea en la posición del cursor
        function insertEmoji(emoji) {
            const textarea = messageInput;
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const value = textarea.value;

            textarea.value = value.substring(0, start) + emoji + value.substring(end);

            // Mover el cursor después del emoji insertado
            textarea.selectionStart = textarea.selectionEnd = start + emoji.length;

            // Disparar un evento 'input' para que la lógica de auto-ajuste de altura y typing indicator se active
            const event = new Event('input', { bubbles: true });
            textarea.dispatchEvent(event);

            textarea.focus(); // Mantener el foco en el textarea
        }


        // Listener para el botón de emoji para mostrar/ocultar el selector
        emojiButton.addEventListener('click', (event) => {
            // Prevenir que el clic en el botón cierre el selector inmediatamente
            event.stopPropagation();
             // Ocultar el dropdown de settings si está visible
             settingsDropdown.style.display = 'none';

            if (emojiPicker.style.display === 'flex') {
                emojiPicker.style.display = 'none';
            } else {
                // Posicionar el selector justo encima de la barra de input
                // bottom del selector = altura del área de input + padding/margen
                const inputAreaHeight = bottomFixedArea.offsetHeight; // Usar la altura del contenedor fijo
                emojiPicker.style.bottom = `${inputAreaHeight + 10}px`; // 10px de margen
                emojiPicker.style.display = 'flex';
            }
        });

        // Ocultar el selector de emojis y el dropdown de settings si se hace clic fuera de ellos
        document.addEventListener('click', (event) => {
            // Si el clic no fue dentro del selector de emojis ni en el botón de emoji
            if (!emojiPicker.contains(event.target) && event.target !== emojiButton) {
                emojiPicker.style.display = 'none';
            }
             // Si el clic no fue dentro del dropdown de settings ni en el botón de settings
             if (!settingsDropdown.contains(event.target) && event.target !== settingsButton) {
                 settingsDropdown.style.display = 'none';
             }
        });


        // --- Lógica para Ajustar Layout con Teclado Virtual ---

        // Función para ajustar el padding inferior del chatBox
        function adjustChatBoxPadding() {
            // Usar un pequeño retraso para asegurar que el DOM esté renderizado y las alturas sean correctas
            setTimeout(() => {
                 // Usar la altura del nuevo contenedor fijo
                 const bottomAreaHeight = bottomFixedArea.offsetHeight;
                 // Añadir un buffer más grande para asegurar espacio suficiente
                 // Puedes ajustar este valor (80) para aumentar o disminuir el espacio inferior
                 const newPaddingBottom = bottomAreaHeight + 80; // <--- Aquí puedes modificar el valor del buffer
                 chatBox.style.paddingBottom = `${newPaddingBottom}px`;
                 console.log(`[${userName}] Adjusted paddingBottom of chatBox to ${chatBox.style.paddingBottom}`); // Debugging log con nombre de usuario
                 console.log(`[${userName}] bottomFixedArea.offsetHeight: ${bottomAreaHeight}`); // Debugging log con nombre de usuario
                 // Intentar scrollear al final después de ajustar el padding
                 chatBox.scrollTop = chatBox.scrollHeight;
            }, 300); // Aumentar el retraso a 300ms
        }


        // Listener para el evento resize de la ventana
        window.addEventListener('resize', adjustChatBoxPadding);

        // Listener para el evento 'focus' en el input de mensaje
        messageInput.addEventListener('focus', () => {
             // Intentar scrollear la caja de chat al final cuando el input recibe foco
             // Esto ayuda a asegurar que la barra de input sea visible
             setTimeout(() => {
                 chatBox.scrollTop = chatBox.scrollHeight;
                 console.log(`[${userName}] Input enfocado, scrolleando chatBox al final con retraso.`); // Debugging log con nombre de usuario
             }, 150); // Retraso para dar tiempo al layout a ajustarse
        });


        // --- Lógica de Responder Mensajes ---

        // Función para iniciar el modo de respuesta
        function startReply(messageData) {
            replyingToMessage = messageData; // Almacenar los datos del mensaje
            replyNameSpan.textContent = messageData.name + ':';
            // Mostrar un fragmento del texto o indicar que es un archivo
            replyTextSpan.textContent = messageData.text ? replyingToMessage.text.substring(0, 50) + (replyingToMessage.text.length > 50 ? '...' : '') : 'Archivo'; // Asumiendo solo texto por ahora

            replyPreview.style.display = 'flex'; // Mostrar la vista previa
            messageInput.focus(); // Poner el foco en el campo de mensaje
            // Ajustar padding después de mostrar la vista previa
            adjustChatBoxPadding();
        }

        // Función para cancelar el modo de respuesta
        function cancelReply() {
            replyingToMessage = null; // Limpiar la referencia al mensaje
            replyPreview.style.display = 'none'; // Ocultar la vista previa
            replyNameSpan.textContent = '';
            replyTextSpan.textContent = '';
            // Ajustar padding después de ocultar la vista previa
            adjustChatBoxPadding();
        }

        // Listener para el botón de cancelar respuesta
        cancelReplyButton.addEventListener('click', cancelReply);


        // --- Lógica del Botón de Configuración y Dropdown ---

        // Listener para el botón de configuración para mostrar/ocultar el dropdown
        settingsButton.addEventListener('click', (event) => {
            // Prevenir que el clic en el botón cierre el dropdown inmediatamente
            event.stopPropagation();
             // Ocultar el selector de emojis si está visible
             emojiPicker.style.display = 'none';

            if (settingsDropdown.style.display === 'flex') {
                settingsDropdown.style.display = 'none';
            } else {
                // Posicionar el dropdown justo debajo y a la derecha del botón de settings
                // Esto se maneja principalmente con CSS position: absolute y top/right
                settingsDropdown.style.display = 'flex';
                // La posición top y right ya están definidas en CSS, pero podrías ajustarlas dinámicamente si fuera necesario
                // const settingsButtonRect = settingsButton.getBoundingClientRect();
                // settingsDropdown.style.top = `${settingsButtonRect.bottom + 5}px`; // 5px debajo del botón
                // settingsDropdown.style.right = `${window.innerWidth - settingsButtonRect.right}px`; // Alinear a la derecha del botón
            }
        });


        // --- Lógica de Presencia (Usuarios en Línea) ---
        function setupPresence() {
             if (!userName) return;

             const userPresenceRef = presenceRef.child(userName);

             // Establecer la presencia a true cuando el usuario se conecta
             userPresenceRef.set(true);
             console.log(`[${userName}] Presence set to true.`);

             // Eliminar la presencia cuando el usuario se desconecta inesperadamente
             userPresenceRef.onDisconnect().remove()
                 .then(() => console.log(`[${userName}] onDisconnect configured to remove presence.`))
                 .catch(error => console.error(`[${userName}] Error configuring onDisconnect:`, error));


             // Establecer la presencia a false cuando el usuario abandona la página (cierra pestaña, navega)
             window.addEventListener('beforeunload', () => {
                 console.log(`[${userName}] beforeunload event detected. Setting presence to false.`);
                 userPresenceRef.set(false); // Establecer a false explícitamente
             });

             window.addEventListener('unload', () => {
                 console.log(`[${userName}] unload event detected. Setting presence to false.`);
                 userPresenceRef.set(false); // Establecer a false explícitamente
             });


             // Escuchar cambios en el nodo de presencia para actualizar la lista de usuarios en línea
             presenceRef.on('value', (snapshot) => {
                 const onlineUsers = snapshot.val();
                 const usersOnline = [];

                 if (onlineUsers) {
                     for (const name in onlineUsers) {
                         // Solo considerar usuarios cuya presencia es explícitamente true y no el usuario actual
                         if (onlineUsers[name] === true && name !== userName) {
                             usersOnline.push(name);
                         }
                     }
                 }

                 // Actualizar el elemento en la interfaz
                 if (usersOnline.length > 0) {
                     onlineUsersDiv.textContent = `En línea: ${usersOnline.join(', ')}`;
                 } else {
                     onlineUsersDiv.textContent = 'Nadie más en línea';
                 }
                 console.log(`[${userName}] Online users updated: ${onlineUsersDiv.textContent}. Raw data:`, onlineUsers);
             }, (error) => {
                 console.error(`[${userName}] Error in presence listener:`, error);
             });
        }


        // Comprobar si hay un nombre guardado en localStorage al cargar la página
        const savedName = localStorage.getItem('chatName');
        if (savedName) {
            userName = savedName; // Establecer userName si se encuentra un nombre guardado
            nameInput.value = savedName; // Rellenar el campo de nombre (aunque no se muestre)
        }

        // Ajustes iniciales al cargar la página
        window.onload = function() {
             // Si hay un nombre guardado, inicializar el chat directamente
             if (localStorage.getItem('chatName')) {
                 userName = localStorage.getItem('chatName'); // Asegurarse de que userName esté establecido
                 namePrompt.style.display = 'none'; // Ocultar la sección de nombre
                 chatInterface.style.display = 'flex'; // Mostrar la interfaz de chat
                 initializeChat(); // Inicializar la carga de mensajes y listeners
             } else {
                  // Si no hay nombre guardado, mostrar el name-prompt y ocultar el chat-interface
                  namePrompt.style.display = 'flex';
                  chatInterface.style.display = 'none';
             }
             // Ajustar el padding inferior del chatBox al cargar
             adjustChatBoxPadding();

             // Add initial click/touch listeners to unlock audio
             document.addEventListener('click', unlockAudio, { once: true });
             document.addEventListener('touchstart', unlockAudio, { once: true });
             sendButton.addEventListener('click', unlockAudio, { once: true }); // Also try on send button click


        };


    </script>

</body>
</html>
